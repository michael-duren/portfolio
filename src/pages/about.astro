---
import { Image } from "astro:assets";
import MainLayout from "../layouts/MainLayout.astro";
import rubberDuck from "../images/duck.png";
import rubberDuckBlue from "../images/duck-blue.png";
import Technologies from "../components/Technologies.astro";
import AnimatedBackground from "../components/AnimatedBackground.astro";
---

<MainLayout title="Michael Duren - About">
  <AnimatedBackground />
  <div class="relative z-10">
    <div class="flex lg:justify-between lg:w-full">
      <div class="flex flex-col gap-2 md:gap-3 lg:gap-4 flex-1">
        <h2 class="font-bold text-2xl md:text-4xl">About Me</h2>
        <div>
          <p class="font-bold text-purple-700">
            What's with the rubber <span class="text-amber-700">duck?</span>
          </p>
          <p class="text-xs text-gray-600">(Try clicking or dragging them!)</p>
        </div>
        <p class="md:text-base text-sm">
          The rubber <span class="font-semibold">duck</span> is a reference to the
          rubber duck debugging method. The idea is that if you are stuck on a problem,
          you should explain it to a rubber duck.
        </p>
        <p class="md:text-base text-sm">
          I ‚ù§Ô∏è this idea, because it is a reminder to take a step back, and
          really look at what you're creating. The new ideas that arise after
          talking through the code can lead us to a solution. Or not, then we
          try something else. Don't take yourself too seriously ü§∑‚Äç‚ôÇÔ∏è.
        </p>
        <p class="font-bold text-purple-700">Anyway...</p>
        <p class="font-semibold text-gray-600 md:text-base text-sm">
          I'm a software engineer with 3+ years building production systems in
          C#/.NET and TypeScript. After years of feature development, I'm
          transitioning toward infrastructure and distributed systems work‚Äî the
          layer that makes applications reliable, observable, and scalable.
        </p>
        <p class="md:text-base text-sm">
          I've built <a href="/work" class="text-purple-700 hover:underline"
            >Next Step CMS</a
          >, a SaaS platform serving 1,200+ users managing chemical dependency
          treatment. I maintain a home monitoring stack with Grafana,
          Prometheus, and node exporters across multiple VMs. I contribute to
          open source projects like Code for Recovery, learning systems
          programming and infrastructure tooling in Go.
        </p>
        <p class="md:text-base text-sm">
          I'm drawn to the problems that live between services: how systems
          communicate, fail, recover, and scale. I want to work on the platforms
          and infrastructure that make great applications possible.
        </p>
      </div>

      <!-- Interactive ducks section -->
      <div class="flex-1 flex-col flex justify-around relative">
        <div class="duck-container">
          <Image
            id="rubber-duck"
            class="floating-duck cursor-grab active:cursor-grabbing"
            src={rubberDuck}
            alt="Rubber Duck"
            draggable="false"
          />
          <Image
            id="rubber-duck-blue"
            class="floating-duck cursor-grab active:cursor-grabbing"
            src={rubberDuckBlue}
            alt="Blue Rubber Duck"
            draggable="false"
          />
        </div>
      </div>
    </div>

    <div class="w-full mt-4">
      <h2 class="font-bold text-2xl">Technologies I use:</h2>
      <Technologies />
    </div>
  </div>

  <audio preload="auto" id="squeek-high" src="/audio/squeek-high.mp3"></audio>
  <audio preload="auto" id="squeek-low" src="/audio/squeek-low.mp3"></audio>
</MainLayout>

<style>
  /* Duck animations */
  .duck-container {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .floating-duck {
    position: relative;
    animation: gentle-float 3s ease-in-out infinite;
    transition: transform 0.3s ease;
    max-width: 200px;
    user-select: none;
  }

  .floating-duck:hover {
    transform: scale(1.1) rotate(5deg);
  }

  .floating-duck:active {
    transform: scale(0.95);
  }

  #rubber-duck {
    animation-delay: 0s;
  }

  #rubber-duck-blue {
    animation-delay: 1.5s;
  }

  @keyframes gentle-float {
    0%,
    100% {
      transform: translateY(0px);
    }
    50% {
      transform: translateY(-20px);
    }
  }

  /* Make ducks draggable on desktop */
  @media (min-width: 768px) {
    .floating-duck {
      position: absolute;
    }

    #rubber-duck {
      top: 20%;
      left: 10%;
    }

    #rubber-duck-blue {
      top: 50%;
      left: 60%;
    }

    .floating-duck.dragging {
      z-index: 1000;
      animation: none;
      cursor: grabbing !important;
    }
  }
</style>

<script>
  import { sound } from "../store/store";

  // Enhanced duck interaction
  document.addEventListener("astro:page-load", () => {
    const ducks = document.querySelectorAll(
      ".floating-duck",
    ) as NodeListOf<HTMLImageElement>;
    const squeekHigh = document.getElementById(
      "squeek-high",
    ) as HTMLAudioElement;
    const squeekLow = document.getElementById(
      "squeek-low",
    ) as HTMLAudioElement;

    ducks.forEach((duck) => {
      let isDragging = false;
      let hasMoved = false;
      let currentX = 0;
      let currentY = 0;
      let initialMouseX = 0;
      let initialMouseY = 0;

      const playSqueak = () => {
        // Only play sound if sound is enabled
        if (sound.get()) {
          if (Math.random() > 0.5) {
            squeekHigh?.play();
          } else {
            squeekLow?.play();
          }
        }
      };

      // Mouse events for desktop
      duck.addEventListener("mousedown", (e: MouseEvent) => {
        e.preventDefault();
        isDragging = true;
        hasMoved = false;
        duck.classList.add("dragging");

        // Store initial mouse position
        initialMouseX = e.clientX;
        initialMouseY = e.clientY;

        // Get current transform values
        const transform = window.getComputedStyle(duck).transform;
        if (transform !== "none" && transform !== "matrix(1, 0, 0, 1, 0, 0)") {
          const matrix = new DOMMatrix(transform);
          currentX = matrix.m41;
          currentY = matrix.m42;
        } else {
          currentX = 0;
          currentY = 0;
        }
      });

      const handleMouseMove = (e: MouseEvent) => {
        if (!isDragging) return;
        e.preventDefault();
        hasMoved = true;

        // Calculate how far the mouse has moved from initial position
        const deltaX = e.clientX - initialMouseX;
        const deltaY = e.clientY - initialMouseY;

        // Add delta to current position
        const newX = currentX + deltaX;
        const newY = currentY + deltaY;

        duck.style.transform = `translate(${newX}px, ${newY}px)`;
      };

      const handleMouseUp = () => {
        if (!isDragging) return;
        isDragging = false;
        duck.classList.remove("dragging");

        // Update current position for next drag
        const transform = window.getComputedStyle(duck).transform;
        if (transform !== "none" && transform !== "matrix(1, 0, 0, 1, 0, 0)") {
          const matrix = new DOMMatrix(transform);
          currentX = matrix.m41;
          currentY = matrix.m42;
        }

        // If didn't move, treat as a click
        if (!hasMoved) {
          playSqueak();
        }
      };

      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);

      // Touch events for mobile
      duck.addEventListener(
        "touchstart",
        (e: TouchEvent) => {
          const touch = e.touches[0];
          if (!touch) return;

          isDragging = true;
          hasMoved = false;
          duck.classList.add("dragging");

          // Store initial touch position
          initialMouseX = touch.clientX;
          initialMouseY = touch.clientY;

          // Get current transform values
          const transform = window.getComputedStyle(duck).transform;
          if (transform !== "none" && transform !== "matrix(1, 0, 0, 1, 0, 0)") {
            const matrix = new DOMMatrix(transform);
            currentX = matrix.m41;
            currentY = matrix.m42;
          } else {
            currentX = 0;
            currentY = 0;
          }
        },
        { passive: true },
      );

      const handleTouchMove = (e: TouchEvent) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        if (!touch) return;

        hasMoved = true;

        // Calculate how far the touch has moved from initial position
        const deltaX = touch.clientX - initialMouseX;
        const deltaY = touch.clientY - initialMouseY;

        // Add delta to current position
        const newX = currentX + deltaX;
        const newY = currentY + deltaY;

        duck.style.transform = `translate(${newX}px, ${newY}px)`;
      };

      const handleTouchEnd = () => {
        if (!isDragging) return;
        isDragging = false;
        duck.classList.remove("dragging");

        // Update current position for next drag
        const transform = window.getComputedStyle(duck).transform;
        if (transform !== "none" && transform !== "matrix(1, 0, 0, 1, 0, 0)") {
          const matrix = new DOMMatrix(transform);
          currentX = matrix.m41;
          currentY = matrix.m42;
        }

        // If didn't move, treat as a tap
        if (!hasMoved) {
          playSqueak();
        }
      };

      document.addEventListener("touchmove", handleTouchMove, { passive: true });
      document.addEventListener("touchend", handleTouchEnd);
    });
  });
</script>
