<div
  id="animated-background"
  class="fixed inset-0 z-10 overflow-hidden pointer-events-none"
>
  <div
    class="absolute top-20 -left-20 w-96 h-96 bg-purple-900 rounded-full mix-blend-screen filter blur-3xl opacity-10 animate-blob"
  >
  </div>
  <div
    class="absolute top-40 -right-20 w-96 h-96 bg-yellow-900 rounded-full mix-blend-screen filter blur-3xl opacity-10 animate-blob animation-delay-2000"
  >
  </div>
  <div
    class="absolute -bottom-32 left-40 w-96 h-96 bg-blue-900 rounded-full mix-blend-screen filter blur-3xl opacity-10 animate-blob animation-delay-4000"
  >
  </div>
  <div
    class="absolute bottom-20 right-20 w-96 h-96 bg-pink-900 rounded-full mix-blend-screen filter blur-3xl opacity-10 animate-blob animation-delay-6000"
  >
  </div>
</div>

<style is:global>
  /* Animated gradient blobs */
  @keyframes blob {
    0% {
      transform: translate(0px, 0px) scale(1);
    }
    33% {
      transform: translate(40px, -60px) scale(1.15);
    }
    66% {
      transform: translate(-30px, 30px) scale(0.9);
    }
    100% {
      transform: translate(0px, 0px) scale(1);
    }
  }

  .animate-blob {
    animation: blob 10s infinite;
  }

  .animation-delay-2000 {
    animation-delay: 2s;
  }

  .animation-delay-4000 {
    animation-delay: 4s;
  }

  .animation-delay-6000 {
    animation-delay: 6s;
  }

  /* Grid pattern background */
  .bg-grid-pattern {
    background-image:
      linear-gradient(to right, #6366f1 1px, transparent 1px),
      linear-gradient(to bottom, #6366f1 1px, transparent 1px);
    background-size: 60px 60px;
  }

  /* Floating geometric shapes */
  .geometric-shapes {
    position: absolute;
    width: 100%;
    height: 100%;
  }

  .shape {
    position: absolute;
    opacity: 0.05;
    animation: float-shape 20s ease-in-out infinite;
  }

  .shape-square {
    width: 60px;
    height: 60px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 8px;
  }

  .shape-circle {
    width: 50px;
    height: 50px;
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    border-radius: 50%;
  }

  .shape-triangle {
    width: 0;
    height: 0;
    border-left: 30px solid transparent;
    border-right: 30px solid transparent;
    border-bottom: 52px solid #4facfe;
  }

  .shape-hexagon {
    width: 50px;
    height: 43.3px;
    background: #43e97b;
    position: relative;
    clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
  }

  @keyframes float-shape {
    0%,
    100% {
      transform: translateY(0px) rotate(0deg);
    }
    25% {
      transform: translateY(-30px) rotate(90deg);
    }
    50% {
      transform: translateY(0px) rotate(180deg);
    }
    75% {
      transform: translateY(30px) rotate(270deg);
    }
  }

  /* Code rain */
  .code-rain {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
  }

  .code-symbol {
    position: absolute;
    font-size: 1.5rem;
    font-weight: bold;
    color: rgba(124, 58, 237, 0.3);
    font-family: "Courier New", monospace;
    transition:
      transform 0.05s linear,
      opacity 0.05s linear;
  }
</style>

<script>
  const symbols = [
    "</>",
    "{}",
    "[]",
    "()",
    "<>",
    "=>",
    "//",
    "fn",
    "ðŸ¦†",
    "ðŸ’»",
    "Î»",
    "#",
    "func",
  ];

  if (!(window as any).codeRainState) {
    (window as any).codeRainState = {
      symbols: [] as Array<{
        element: HTMLElement;
        x: number;
        y: number;
        speed: number;
        rotation: number;
        rotationSpeed: number;
        symbol: string;
      }>,
      animating: false,
    };
  }

  const state = (window as any).codeRainState;

  function initCodeRain() {
    const container = document.getElementById("code-rain");
    if (!container) return;

    if (state.symbols.length > 0) {
      state.symbols.forEach((item: any) => {
        container.appendChild(item.element);
      });
      return;
    }

    const symbolCount = 12;
    for (let i = 0; i < symbolCount; i++) {
      const element = document.createElement("span");
      element.className = "code-symbol";
      element.textContent = symbols[i % symbols.length] ?? null;

      // Initial random position
      const x = Math.random() * 100;
      const y = Math.random() * 100; // Start visibly distributed
      const speed = 0.1 + Math.random() * 0.5;
      const rotation = Math.random() * 360;
      const rotationSpeed = (Math.random() - 0.5) * 2;

      // Use transform for positioning to avoid layout thrashing
      // We'll set left to 0 and top to 0 in CSS or assume common reset,
      // dealing purely in transforms relative to the container
      element.style.left = "0";
      element.style.top = "0";
      element.style.transform = `translate3d(${x}vw, ${y}vh, 0) rotate(${rotation}deg)`;
      element.style.opacity = "0.3";
      element.style.willChange = "transform, opacity";

      container.appendChild(element);

      state.symbols.push({
        element,
        x,
        y, // y is in vh units effectively
        speed,
        rotation,
        rotationSpeed,
        symbol: element.textContent,
      });
    }
  }

  function animateCodeRain() {
    state.symbols.forEach((item: any) => {
      item.y += item.speed;
      item.rotation += item.rotationSpeed;

      // Reset if off screen
      if (item.y > 110) {
        item.y = -10;
        item.x = Math.random() * 95;
      }

      // Use translate3d for GPU acceleration and to avoid layout shifts
      item.element.style.transform = `translate3d(${item.x}vw, ${item.y}vh, 0) rotate(${item.rotation}deg)`;

      // Opacity fade in/out at edges
      let opacity = 0.3;
      if (item.y < 0) {
        opacity = 0;
      } else if (item.y < 10) {
        opacity = 0.3 * (item.y / 10);
      } else if (item.y > 90) {
        opacity = 0.3 * ((110 - item.y) / 20);
      }

      item.element.style.opacity = opacity.toString();
    });

    requestAnimationFrame(animateCodeRain);
  }

  if (!state.animating) {
    // Only start animation loop once
    state.animating = true;
    requestAnimationFrame(animateCodeRain);
  }

  // Initialize checks
  document.addEventListener("astro:page-load", () => {
    initCodeRain();
  });

  // Initial load fallback
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initCodeRain);
  } else {
    initCodeRain();
  }

  document.addEventListener("astro:before-preparation", () => {
    const container = document.getElementById("code-rain");
    if (container && state.symbols.length > 0) {
      state.symbols.forEach((item: any) => {
        if (item.element.parentNode) {
          item.element.parentNode.removeChild(item.element);
        }
      });
    }
  });
</script>
